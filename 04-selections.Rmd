```{r load_dgr_04, include=FALSE, results=FALSE}
library(DiagrammeR)
```

```{r make_simple_property_graph, include=FALSE, results=FALSE}
property_graph <-
  create_random_graph(
    n = 4,
    m = 6,
    directed = TRUE,
    set_seed = 23) %>%
  select_nodes() %>%
  set_node_attrs(
    node_attr = "label",
    values = c("sjd", "qhd", "i0p", "235")) %>%
  set_node_attrs(
    node_attr = "type",
    values = c("A", "A", "B", "B")) %>%
  select_edges() %>%
  set_edge_attrs(
    edge_attr = "rel",
    values = c("X", "X", "Y", "Y", "Z", "Z")) %>%
  set_edge_attrs(
    edge_attr = "weight",
    values = c(3.7, 8.3, 12.5, 1.3, 2.9, 2.4))
```

# Selections {#selections}

Occasionally, you'll want to operate on a select group of nodes or edges. Some functions affect a single node or edge while others (or, sometimes, the same functions) operate on all nodes or edges in a graph. Selections allow you to target specified nodes or edges and then apply specialized functions to operate on just those selected entities. Most of the selection functions support rudimentary set operations across several calls of the selection functions (i.e., for the union, intersection, or difference between selected sets of nodes or edges).

## Setup for this Chapter

Ensure that the latest development build of **DiagrammeR** is installed. If the **devtools** package is not availble in your **R** library, install it and then use the `install_github()` function to get the latest **DiagrammeR** build. 

```{r install_packages_dgr_chp_04, eval=FALSE, include=TRUE, results=FALSE}
install.packages("devtools")
devtools::install_github("rich-iannone/DiagrammeR")
```

```{r library_chp_04, eval=FALSE, include=TRUE, results=FALSE}
library(DiagrammeR)
```

For this chapter, the graph `property_graph` has been created and it's a simple property graph of 4 nodes and 6 edges. Numerical values are assigned to the nodes as the `value` attribute and to the edges as the `weight` attribute. Nodes have unique `label` values, and, `type` group labels are available for nodes (as `A` and `B`) and `rel` values are set for the edges (as `X`, `Y`, and `Z`). This schematic provides a visual representation of the graph as well as the attributes and data associated with each node and edge.

<img src="diagrams/property_graph_chp_04.png">

This graph adheres to the concept of a property graph as in that:

- all nodes have an assigned, non-`NA` `type` value
- all edges have an assigned, non-`NA` `rel` value

We can always verify whether a graph satisfies these conditions with the `is_property_graph()` function, which either returns a `TRUE` or `FALSE` logical result.

```{r is_property_graph}
is_property_graph(property_graph)
```

We'll use this graph in most of the chapter examples to demonstrate how selections work. Working with a property graph in such examples is especially useful for showing how more complicated selections can be accomplished (i.e., using set operations and/or conditional statements).

## The Selection Functions

The following table provides a summary of all the available `select_...()` functions available in **DiagrammeR**.

```{r, echo=FALSE, results='asis'}
library(knitr)

kable(
  data.frame(
    Function = 
      c(
        "`select_nodes()`",
        "`select_nodes_by_id()`",
        "`select_last_nodes_created()`",
        "`select_nodes_by_degree()`",
        "`select_nodes_in_neighbourhood()`",
        "`select_edges()`",
        "`select_edges_by_edge_id()`",
        "`select_edges_by_node_id()`",
        "`select_last_edges_created()`",
        "`select_rev_edges_ws()`"
      ),
    Description = 
      c(
        "Select nodes graph using filtering conditions.",
        "Select nodes by their ID values.",
        "Select the last group of nodes created in the graph.",
        "Select nodes on the basis of node degree.",
        "Select nodes based on a walk distance from a specified node.",
        "Select nodes graph using filtering conditions.",
        "Select edges by their ID values.",
        "Select edges associated with specified node ID values.",
        "Select the last group of edges created in the graph.",
        "Select any reverse edges from a selection of edges."
        )))
```

When any selection is performed using using a `select_...()` function, the selection is stored in the graph object. We can always use `get_selection()` to verify this:

```{r select_nodes_get_selection}
# Select nodes `1` and `4` of
# `property_graph` and then return
# the node IDs for the selection
property_graph %>%
  select_nodes(nodes = c(1, 4)) %>%
  get_selection()
```


## Creating a Node Selection

Let's begin with an in-depth look on how to select graph nodes using the `select_nodes()` function. 
Selecting nodes in a graph with `select_nodes()` can be done in multiple ways:

- providing only a set of node ID values
- by providing one or more filtering statements to `conditions`
- doing both of the above, where each set of values/statements work toward filtering the nodes that will comprise the node selection

Here is an example of the first case, where you know which node ID values should make up the node selection:

```{r select_nodes_2_ids}
# Create a 5-node graph and select
# nodes `1` and `3`; show
# the final node selection
create_graph() %>%
  add_n_nodes(5) %>%
  select_nodes(nodes = c(1, 3)) %>%
  get_selection()
```

The `select_nodes_by_id()` function serves as a plug-in replacement for `select_nodes()` when used exactly in this way. Its `nodes` argument simply takes a vector of node ID values.

```{r select_nodes_by_id_2_ids}
# Create a 5-node graph and select
# nodes `1` and `3` using the
# `select_nodes_by_id()` function
create_graph() %>%
  add_n_nodes(5) %>%
  select_nodes_by_id(nodes = c(1, 3)) %>%
  get_selection()
```

If you don't know the node ID values that should be part of a selection, and this is often the case in practice, you can use a vector of filtering statements as `conditions`. Some of these can be `conditions = "type == 'z'"` (selecting nodes where the `type` value is `z`), or `conditions = "value > 3.0"` (node selection where the `value` attribute is greater than `3.0`), or, `conditions = c("value < 2.0", "type %in% c('a', 'b', 'd')")` (all nodes with `value` less than `2.0` and having a `type` value of `a`, `b`, or `d`).



```{r}
# The `property_graph` is, indeed, a
# property graph; let's select all nodes
# of type `a`
property_graph %>%
  select_nodes(
    conditions = "type == 'A'") %>%
  create_subgraph_ws() %>%
  get_node_df()
```

```{r}
# Now, get all nodes with a `value`
# greater than 4.0
property_graph %>%
  select_nodes(
    conditions = "value > 4.0") %>%
  create_subgraph_ws() %>%
  get_node_df()
```

A vector of `condition` statements creates a set of `AND` conditions, so, all conditions need to be fulfilled in the selection of nodes. We can also specify conditions with a set of `OR` conditions 

## Consecutive Selections

The situation may arise when a more specialized match needs to be made (i.e., matching this but not that, or, matching two different types of things). This is where the `set_op` argument (short for *set operation*) becomes useful. Multiple function calls with the `select_nodes_by_id()` function, for instance, can modify the set of selected nodes depending on the option provided in the `set_op` argument. These set operations are:

* `union` — creates a union of selected nodes in consecutive operations that create a selection of nodes (this is the default option)
* `intersect` — modifies the list of selected nodes such that only those nodes common to both consecutive node selection operations will retained
* `difference` — modifies the list of selected nodes such that the only nodes retained are those that are different in the second node selection operation compared to the first

These set operations behave in exactly the same way as the base **R** functions `union()`, `intersect()`, and `setdiff()`. Furthermore, most of the `select_...()` functions contain the `set_op` argument, so, they behave the same way with regard to modifying the node or edge selection in a series of consecutive selection operations.

For a graph with 5 nodes (with IDs `1` through `5`), creating an initial selection of nodes with `select_nodes()` will result in the selection of all 10 nodes in the graph. A subsequent call of `select_nodes_by_id()` specifying `nodes = c(1, 3, 5)` and `set_op = "difference"` will result in a selection of nodes `2` and `4`. We can verify the selection any time with the `get_selection()` function. Here is a the complete pipeline, starting with `create_graph()` and finishing with `get_selection()`:

```{r select_nodes_2x_w_difference}
# Create a 5-node graph and use 2
# `select_...()` functions; show
# the final node selection
create_graph() %>%
  add_n_nodes(5) %>%
  select_nodes() %>%
  select_nodes_by_id(
    nodes = c(1, 3, 5),
    set_op = "difference") %>%
  get_selection()
```


