[
["intro.html", "DiagrammeR Documentation Chapter 1 Introduction", " DiagrammeR Documentation Richard Iannone 2017-02-12 Chapter 1 Introduction "],
["creation.html", "Chapter 2 Graph Creation 2.1 Getting Started 2.2 Creating a Graph Object and Adding Nodes and Edges 2.3 Creating a Simple Graph Using Data Frames 2.4 Moving Toward Nodes and Edges with More Descriptive Attributes", " Chapter 2 Graph Creation Creating a graph object is undoubtedly important. I dare say it is one of the fundamental aspects of the DiagrammeR world. With the graph object produced, so many other things are possible. For instance, you can inspect certain aspects of the graph, modify the graph in many ways that suit your workflow, view the graph (or part of the graph!) in the RStudio Viewer, or perform graph traversals and thus create complex graph queries using magrittr (%&gt;%) or pipeR (%&gt;&gt;%) pipelines. The possibilities are really very exciting and it all begins with creating those graph objects. 2.1 Getting Started Before we dive into making a graph with DiagrammeR we’d want to be sure some things are in order. First, we need to make sure we have the package installed in R. While the package is available on CRAN, it’s recommended that the development version of DiagrammeR is used. It’s available on GitHub and to install packages from there, we need to use the devtools package. (If not installed use install.packages(&quot;devtools&quot;).) After that, get the development build of DiagrammeR using devtools::install_github(&quot;rich-iannone/DiagrammeR&quot;). Finally, load the package with: library(DiagrammeR) A few notes are useful here, the package automatically enables the magrittr pipe operator (%&gt;%) which allows for chaining between statements in a left-to-right, easy-to-read manner. The pipeR package’s %&gt;&gt;% (which works very similarly) is not loaded by DiagrammeR but it can be used. In the examples throughout, we’ll stick with magrittr’s pipe. 2.2 Creating a Graph Object and Adding Nodes and Edges Let’s get to making a graph. The create_graph() function creates a graph object and, optionally, allows for intialization of nodes, edges, and a few global attributes for the graph. We can create an empty graph by simply using create_graph() as is. graph_e &lt;- create_graph() This really is an empty graph (no nodes) and we can quickly verify this by using the node_count() function. node_count(graph_e) ## [1] 0 You can add individual nodes to a graph by using the add_node() function. Let’s add two nodes in the most minimal fashion: graph_1n &lt;- add_node(graph = graph_e) graph_2n &lt;- add_node(graph = graph_1n) This creates 2 nodes with ID values 1 and 2 (ID values are set for you as auto-incrementing integers). There are a few functions that can be used to check that these additions did occur. We can get a count of nodes as before with the node_count(): # Count the number of nodes in each graph produced c(node_count(graph = graph_e), node_count(graph = graph_1n), node_count(graph = graph_2n)) ## [1] 0 1 2 Alternatively, we can use the get_node_ids() function to return a vector of node ID values: # Get the node ID values for `graph_2n`; note that # the data argument is `x` and not `graph` get_node_ids(x = graph_2n) ## [1] 1 2 Finally, we can visualize the graph by using the render_graph() function. They nodes typically appear very large when there are few of them but scale down in size if there are many. The values shown inside the nodes are the automatically-assigned node ID values. If we were to assign label values to each of the nodes (which could be done when using add_node(label = &quot;label_name&quot;), for example), those values would be shown instead. render_graph(graph = graph_2n) Adding nodes does not automatically add edges. We can check that there are no edges in the graph by using the edge_count() function. A graph with no edges will return 0. edge_count(graph = graph_2n) ## [1] 0 The vast majority of the functions in DiagrammeR have the graph argument (or x as we’ve seen) as their first argument. This is useful in the context of using the magrittr pipe operator, %&gt;% as we can start with a graph object, perform a transformation on that graph, expect a modified graph, and use that as input for the next transformation function, all while joining such operations with the pipe. With this piping approach, we can create the same graph as before (2 nodes, no edges) by chaining with %&gt;%: # Create the equivalent `graph_2n` object # but use `%&gt;%` to avoid intermediate objects graph_2n_piped &lt;- create_graph() %&gt;% add_node() %&gt;% add_node() # Verify that the graph contains 2 nodes node_count(graph_2n_piped) ## [1] 2 The benefits are pretty obvious over the nested approach that avoids creating intermediate graph objects. # Create the equivalent `graph_2n` object # using nested function calls graph_2n_nested_fcns &lt;- add_node( add_node( create_graph())) # Verify that the graph contains 2 nodes node_count(graph_2n_nested_fcns) ## [1] 2 With the %&gt;%, the sequence of operations is more easily readable (left to right), plus, only one name to create! The less names the better. Moreover, and not shown above, the situtation for the nested approach gets more confusing as we add arguments and their values (of which, there can be many). So, we have a made a graph with 2 nodes. The next reasonable thing to do would be adding an edge between the nodes. By default, new graphs produced with create_graph() are directed graphs. To review, a directed graph is one where any edge between a pair of nodes has a defined direction (e.g., by the definition 1-&gt;2, we mean to say that edge is directed from node 1 to node 2). Most of what is covered in this book deals with directed graph but we may occasionally delve into undirected graphs (where edges have no specified direction between nodes). At any rate, using create_graph(directed = FALSE) will create an empty graph designated as undirected (i.e., any edges added will be directionless). Let’s use a pipeline with %&gt;% to create a graph with 2 nodes and the edge with definition 1-&gt;2. This requires three different functions (create_graph(), add_node(), and add_edge()): # Create a graph with 2 nodes and 1 edge graph_2n_1e &lt;- create_graph() %&gt;% add_node() %&gt;% add_node() %&gt;% add_edge(from = 1, to = 2) # Describe the graph paste(&quot;This graph has:&quot;, node_count(graph_2n_1e), &quot;nodes,&quot;, edge_count(graph_2n_1e), &quot;edges&quot;) ## [1] &quot;This graph has: 2 nodes, 1 edges&quot; We can be sure we created the correct edge definition (1-&gt;2) by using the get_edges() function: # The graph has 1 edge, what is its # edge definition? get_edges(graph_2n_1e) ## [1] &quot;1-&gt;2&quot; We now have this simple and small graph. We can view it again by calling the render_graph() function. You probably do not want to assign the graph to an object when calling render_graph() (as you would likely mistakenly overwrite a graph you’ve previously made). We are purely using this function for its side effect, which is viewing. We can view the graph using the Graphviz renderer: # Show the graph using the Graphviz engine render_graph(graph = graph_2n_1e) And also, if you like interactivity and fluid physical motions, the visNetwork renderer. # Show the graph using the visNetwork engine render_graph(graph = graph_2n_1e, output = &quot;visNetwork&quot;) Just as we’ve built up a graph, and can do the opposite and remove edges and nodes. The key functions here are delete_edge() and delete_node(). Let’s remove the edge we just recently added and then remove each of the nodes, leaving us again with an empty graph. Note again that we don’t need to repeat the graph’s object name throughout this pipeline (which is nice, saves typing). Second useful note: typing delete_edge( and then hitting the tab in RStudio brings up useful information on the function’s argument names along with useful descriptions. I find this very helpful and use this feature quite often. # Remove the edge from the graph, then, # remove each of the 2 nodes graph_2n_1e_empty &lt;- graph_2n_1e %&gt;% delete_edge(from = 1, to = 2) %&gt;% delete_node(node = 2) %&gt;% delete_node(node = 1) # Verify that there are no nodes left # in this graph object node_count(graph_2n_1e_empty) ## [1] 0 There are some shortcuts/variations for doing the same thing (there are often numerous ways to transform graphs). You could simply call delete_node() twice, for instance, to get an empty graph. This is because removing a node with edges attached will automatically remove those edges. If we were now to display the graph with render_graph() you would get a field of nothingness. Since that’s not very interesting, I’m not going to show it here. 2.3 Creating a Simple Graph Using Data Frames For many graph diagrams you may need many nodes and edges. Let’s use the create_node_df() function to specify a collection of nodes and contain them in a data frame (a node data frame, or ndf). Immediately after that, inspect the node data frame. ndf &lt;- create_node_df( n = 3, label = TRUE) ndf ## id type label ## 1 1 &lt;NA&gt; 1 ## 2 2 &lt;NA&gt; 2 ## 3 3 &lt;NA&gt; 3 The n argument is required here and it must indicate the number of nodes you intend this object to contain. The use of label = TRUE allows for copying of the node IDs as the node label (which is a node attribute). This is not always desirable, however. A better option is to specify a vector of label values (you can use all manner of characters, it will be coerced to a character vector). Make certain that this vector is the same length as specified by n. Also, if we ensure that the label node attribute always contains unique values, we can later select individual nodes by their label values and perform actions on these selections. You may have noticed the node attribute type in the output. Values may optionally be provided for this attribute and, again, having this extra metadata is useful for categorizing collections of nodes. Let’s refine the ndf object and include two different type values (A and B). ndf &lt;- create_node_df( n = 3, type = c(&quot;A&quot;, &quot;A&quot;, &quot;B&quot;), label = TRUE) ndf ## id type label ## 1 1 A 1 ## 2 2 A 2 ## 3 3 B 3 Now onto the edges, those connections between the nodes. The edges are also collected in a data frame (this time, as an edge data frame or edf). The create_edge_df() function is used to generate this type of object. edf &lt;- create_edge_df( from = c(1, 1), to = c(2, 3)) edf ## id from to rel ## 1 1 1 2 &lt;NA&gt; ## 2 2 1 3 &lt;NA&gt; The from and to arguments specify which nodes for the edge are outgoing and incoming, respectively. Here, the edges are: 1-&gt;2 and 1-&gt;3. As stated before, for directed graphs, the order is essential. The rel argument allows for the inclusion of text labels in the same manner as the node type. This is useful for targeting specific groups of edges during a selection or traversal. Let’s refine the edf object and include two different rel values (X and Y). edf &lt;- create_edge_df( from = c(1, 1), to = c(2, 3), rel = c(&quot;X&quot;, &quot;Y&quot;)) edf ## id from to rel ## 1 1 1 2 X ## 2 2 1 3 Y Now that we have an ndf and an edf, we can now combine those into a new graph object by using those specialized data frames within the create_graph() function call. # Create a graph object using node and # edge data frames graph_ndf_edf &lt;- create_graph( nodes_df = ndf, edges_df = edf) What exactly happened? These data frames (ndf and edf) were placed within the graph object when it was created. They essentially became internal ndf and edf objects. We can inspect the graph’s internal ndf and edf at any time using the get_node_df() and get_edge_df() functions: # Show the graph&#39;s internal node data frame get_node_df(graph_ndf_edf) ## id type label ## 1 1 A 1 ## 2 2 A 2 ## 3 3 B 3 # Show the graph&#39;s internal edge data frame get_edge_df(graph_ndf_edf) ## id from to rel ## 1 1 1 2 X ## 2 2 1 3 Y Let’s view the graph using render_graph(). The output will clearly show us how the 3 nodes are connected to each other. # Show the graph using `render_graph()` render_graph(graph = graph_ndf_edf) There is a bit more that you can do with node and edge data frames. Extra columns (or attributes) filled with values can be used for several purposes: to associate data values that relate to each node or edge to provide styling attributes such as color names or relative node sizes We can add these extra columns/attrs when making the node or edge data frames. Here is an example where color attribute values for nodes and edges is provided along with some fillcolor values for nodes. # Create a node data frame 2.4 Moving Toward Nodes and Edges with More Descriptive Attributes Note that whenever we use the default values for type or label in each add_node() call, we don’t get values for the type attribute and the label attribute is assigned the node ID value. In the ideal case, values for type and label are supplied. Something to keep in mind is that including label values that are unique or distinct across all nodes in the graph will make it possible to specify node selections and perform useful actions on specific nodes. Let’s create the graph object once more with type and label node attributes included. graph_node_type_label &lt;- create_graph() %&gt;% add_node(type = &quot;number&quot;, label = &quot;one&quot;) %&gt;% add_node(type = &quot;number&quot;, label = &quot;two&quot;) View the graph’s internal node data frame with the get_node_df() function so we can see that these attributes have been included alongside the graph’s nodes. get_node_df(graph_node_type_label) ## id type label ## 1 1 number one ## 2 2 number two Now let’s add a single, directed edge between nodes 1 and 2 using add_edge(). This edge will also be given a value for its rel attribute (to_number). After adding the edge to the graph, use the get_edges() function to show that the edge has been produced. # Add an edge between nodes `1` and `2` and # set the `rel` attribute as `to_number` graph_edge_w_ids &lt;- graph_node_type_label %&gt;% add_edge( from = 1, to = 2, rel = &quot;to_number&quot;) # Display the graph&#39;s edges (in the default # string vector format with node IDs separated # by arrows in this directed graph case) graph_edge_w_ids %&gt;% get_edges() ## [1] &quot;1-&gt;2&quot; Perhaps you don’t want to work directly with the node ID values and instead with unique node labels. This is a common practice as node ID values can be considered as less meaningful (they are not assigned by the user) but node labels and other attributes can give each node an identity and make nodes more distinguishable. In such a workflow, it’s easier to create edges based on the node label values. Supply the node labels as values for the from and to arguments and set use_labels to TRUE. To view the graph’s edges after the transformation, use get_edges() as before but, this time, use return_values = &quot;label&quot; to display the graph’s edges in terms of node label values. # Add an edge between the nodes with labels # `one` (node `1`) and `two` (node `2`) and # set the `rel` attribute as `to_number` graph_edge_w_ids &lt;- graph_node_type_label %&gt;% add_edge( from = &quot;one&quot;, to = &quot;two&quot;, rel = &quot;to_number&quot;, use_labels = TRUE) # Display the graph&#39;s edges (as a string-based # vector with pairs of node `label` values) graph_edge_w_ids %&gt;% get_edges(return_values = &quot;label&quot;) ## [1] &quot;one-&gt;two&quot; The get_edges() function can output the pairs of nodes in edges either as a character vector (as above, which is the default), as a data frame (with 2 columns: from and to), or as a list (first component is the from vector and the second represents the to nodes). Here are examples of the latter two output types: # Get the graph&#39;s edges as a data frame get_edges(graph_edge_w_ids, return_type = &quot;df&quot;) ## from to ## 1 1 2 # Get the graph&#39;s edges as a list get_edges(graph_edge_w_ids, return_type = &quot;list&quot;) ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 2 The addition of a node and the creation of edges can also be performed in a single add_node() step. You can use either (or both) of the optional from and to arguments in the add_node() function. Let’s make various graph objects and see how both nodes and edges can be created with a single call to add_node(). # Add initial node (ID `1`) and then # add node `2` and edge `1-&gt;2` graph_a &lt;- create_graph() %&gt;% add_node() %&gt;% add_node(from = 1) # Add initial node (ID `1`) and then # add node `2` and edge `2-&gt;1` graph_b &lt;- create_graph() %&gt;% add_node() %&gt;% add_node(to = 1) # Add 2 initial nodes (IDs `1` and # `2`) and then add node `3` and edges # `2-&gt;3` and `3-&gt;1` graph_c &lt;- create_graph() %&gt;% add_node() %&gt;% add_node() %&gt;% add_node(from = 2, to = 1) # Get all of the edges available in # each of the graphs created list(graph_a = get_edges(graph_a), graph_b = get_edges(graph_b), graph_c = get_edges(graph_c)) ## $graph_a ## [1] &quot;1-&gt;2&quot; ## ## $graph_b ## [1] &quot;2-&gt;1&quot; ## ## $graph_c ## [1] &quot;2-&gt;3&quot; &quot;3-&gt;1&quot; There are many other ways to generate a node and connect that new node to existing nodes. The from and to arguments of add_node() also accept vectors of length greater than 1. So, a new node can be connected to or from multiple nodes already in the graph. To make an example of this more succinct, we can use the node creation function add_n_nodes(). Supplying a number for the n argument creates n nodes in the graph. The add_n_nodes() function has no means to create edges like add_node() but it’s a great way to simply add a lot of nodes to the graph with one function call. Below, an example of adding one node to many nodes: # Create a graph, add 5 nodes, and then # add a node with edges to nodes `1` to `5` graph_d &lt;- create_graph() %&gt;% add_n_nodes(n = 5) %&gt;% add_node(to = 1:5) # View the graph in the RStudio Viewer render_graph(graph = graph_d) While this works and produces the result that was intended, it’s slightly inconvenient. We have to mentally keep track of which node ID values were created and use those directly in the from or to arguments to create the edges. A better way is to capture a selection of nodes and perform graph transformations with an active selection: # Create a graph, add 5 nodes, set those nodes # as a node selection, and then add a new node # with edges to all nodes in the selection graph_e &lt;- create_graph() %&gt;% add_n_nodes(n = 5) %&gt;% select_last_nodes_created() %&gt;% add_node(to = get_selection(.)) # View the graph in the RStudio Viewer render_graph(graph = graph_e) This produces the same graph as before but, this time, we didn’t have to manually supply node ID values. The select_last_nodes_created() function simply made a selection of node ID values and we retrieved those IDs using the get_selection() function. The dot (.) as the sole argument referred to the graph itself, which is needed for the graph argument to get_selection. While the graph was constructed to our specification, the nodes and the edges within that graph do not have their basic attributes filled with values. We can check this using get_node_df() and get_edges_df and we see that values for the type, label, and rel attributes are all NA values. get_node_df(graph = graph_e) ## id type label ## 1 1 &lt;NA&gt; &lt;NA&gt; ## 2 2 &lt;NA&gt; &lt;NA&gt; ## 3 3 &lt;NA&gt; &lt;NA&gt; ## 4 4 &lt;NA&gt; &lt;NA&gt; ## 5 5 &lt;NA&gt; &lt;NA&gt; ## 6 6 &lt;NA&gt; &lt;NA&gt; get_edge_df(graph = graph_e) ## id from to rel ## 1 1 6 1 &lt;NA&gt; ## 2 2 6 2 &lt;NA&gt; ## 3 3 6 3 &lt;NA&gt; ## 4 4 6 4 &lt;NA&gt; ## 5 5 6 5 &lt;NA&gt; These values can be added later. All type and label values for nodes can be specified using set_node_attrs(). Likewise, all rel values for edges can be set with the set_edge_attrs() function. To do this unconditionally to all nodes and edges in the graph: graph_f &lt;- graph_e %&gt;% set_node_attrs( node_attr = &quot;label&quot;, values = c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;)) %&gt;% set_node_attrs( node_attr = &quot;type&quot;, value = &quot;a&quot;) %&gt;% set_edge_attrs( edge_attr = &quot;rel&quot;, values = &quot;to_number&quot;) To verify that the changes were applied, use the get_node_df() and get_edge_df() function to output the graph’s internal node and edge data frames. get_node_df(graph_f) ## id type label ## 1 1 a one ## 2 2 a two ## 3 3 a three ## 4 4 a four ## 5 5 a five ## 6 6 a six get_edge_df(graph_f) ## id from to rel ## 1 1 6 1 to_number ## 2 2 6 2 to_number ## 3 3 6 3 to_number ## 4 4 6 4 to_number ## 5 5 6 5 to_number Alternatively, we can use the get_node_attrs() and get_edge_attrs() functions to look at individual attribute values for graph nodes and edges. By supplying the graph object and the name of the attribute (e.g., type for nodes, rel for edges), we get a named vector of node or edge attribute values. # Get a vector of values for the `type` node # attribute; this returns a named vector (where # the names are the node ID values) type_node_attr_values &lt;- get_node_attrs(x = graph_f, node_attr = &quot;type&quot;) # Get a vector of values for the `rel` edge # attribute; this also returns a named vector # (where the names are the edge definitions) rel_edge_attr_values &lt;- get_edge_attrs(x = graph_f, edge_attr = &quot;rel&quot;) # Place these node and edge attribute vectors in # a list and display it list(type_node_attr_values = type_node_attr_values, rel_edge_attr_values = rel_edge_attr_values) ## $type_node_attr_values ## 1 2 3 4 5 6 ## &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; ## ## $rel_edge_attr_values ## 6-&gt;1 6-&gt;2 6-&gt;3 6-&gt;4 6-&gt;5 ## &quot;to_number&quot; &quot;to_number&quot; &quot;to_number&quot; &quot;to_number&quot; &quot;to_number&quot; View the graph again to see that all edges are labeled with the to_number rel edge attribute. We will render the graph using output = visNetwork since that rendering method automatically includes node label and edge rel values (but not the edge type). render_graph(graph = graph_f, output = &quot;visNetwork&quot;) Go ahead, play with the graph by dragging nodes this way and that way. It’s fun! Graphs should always be this fun… "],
["attrs.html", "Chapter 3 Graph Attributes 3.1 Adding Attributes in NDFs and EDFs Outside of a Graph 3.2 Adding Attributes to Nodes or Edges Already in the Graph 3.3 Setting Attributes Globally or Selectively 3.4 Adding Attributes to Selections of Nodes or Edges", " Chapter 3 Graph Attributes A graph can often convey more useful information when aesthetic properties are applied to its rendered form. 3.1 Adding Attributes in NDFs and EDFs Outside of a Graph One way to add node or edge attributes, using the functions we’ve already explored, is to include the these attributes and their values when generating node and edge data frames. For a node data frame, we can provide our own argument names and values when calling the create_node_df() function. In the example below, we provide values for n (the number of nodes, 4 in this case), label, and type but, in addition, we add the columns: color, shape, and data. Note that we either provide a single-length vector (i.e., a single value) or an n-length vector. Anything in between results in NA values applied to fill in the length of the data frame. The color and shape node attributes are instantly recognized by the Graphviz rendering engine. (Having the correct types of values are important here, more on that later.) The data column is ignored by the rendering engine, however, it is useful to have for other reasons (more on this later, as well). # Create a node data frame and display it ndf &lt;- create_node_df( n = 4, label = TRUE, type = &quot;lower&quot;, color = &quot;lightgreen&quot;, shape = c(&quot;circle&quot;, &quot;circle&quot;, &quot;rectangle&quot;, &quot;rectangle&quot;), data = c(2.5, 5.6, 7.4, 1.7)) ndf ## id type label color shape data ## 1 1 lower 1 lightgreen circle 2.5 ## 2 2 lower 2 lightgreen circle 5.6 ## 3 3 lower 3 lightgreen rectangle 7.4 ## 4 4 lower 4 lightgreen rectangle 1.7 We can include this node data frame in a new graph and then render it using the Graphviz engine (using render_graph() with no arguments except graph). Let’s have a look. # Incorporate the node data frame into a # new graph and display that graph; note that # there are styling attributes being used graph_4n &lt;- create_graph( nodes_df = ndf) render_graph(graph_4n) We can take a very similar approach to adding styling attributes and a data column to an edge data frame with the create_edge_df() function. Here, let’s add the penwidth (line thicknesses for edges) and the color sytling attributes, and, a data attribute column. # Create e node data frame and display it edf &lt;- create_edge_df( from = c(1, 4, 3), to = c(2, 1, 1), rel = &quot;related_to&quot;, penwidth = c(2.5, 0.5, 1.0), color = c(&quot;pink&quot;, &quot;red&quot;, &quot;lightblue&quot;), data = c(1.1, 5.2, 3.4)) edf ## id from to rel penwidth color data ## 1 1 1 2 related_to 2.5 pink 1.1 ## 2 2 4 1 related_to 0.5 red 5.2 ## 3 3 3 1 related_to 1.0 lightblue 3.4 Now that we have the edge data frame (edf), let’s add that to the graph with the add_edge_df() function. Then, render the graph to see the styled nodes and edges. # Add the edge data frame to the graph # object, then, render the graph graph_4n_3e &lt;- graph_4n %&gt;% add_edge_df( edge_df = edf) render_graph(graph_4n_3e) 3.2 Adding Attributes to Nodes or Edges Already in the Graph We can use the data fields for both the nodes and the edges to create styling attributes. Doing this generally requires scaling of the values (if they are numerical data, and they are in this case) and generating a new column in the internal ndf or edf that’s named for the styling attribute. Thankfully, we have some useful functions to help with this: rescale_node_attrs() and rescale_edge_attrs(). Let’s look at an example of how this works for scaling up the sizes of the node shape: # Create the `width` node attribute column # by scaling the values in the `data` column # to between 0.5 and 1.5 units graph_scaled_nodes &lt;- graph_4n_3e %&gt;% rescale_node_attrs( node_attr_from = &quot;data&quot;, to_lower_bound = 0.5, to_upper_bound = 1.5, node_attr_to = &quot;width&quot;) # Display the graph with the new styling # attribute applied render_graph(graph_scaled_nodes) This looks pretty good and, conceptually, it isn’t too difficult to reason about generating new columns with specific attribute names based on data in existing columns. Notice that the circular nodes were scaled up or down evenly whereas the rectangular one was only scaled horizontally (and this makes sense, we made a width attribute/column). If we wanted scaling both in width and in height, we also need a height column with the same scaled values. There is a set of functions to make this process easier: copy_node_attrs() and copy_edge_attrs(). It simply copies values from one attribute to a new attribute. # Copy the `width` attribute values to # a new `height` attribute; because we # want square rectangles graph_square_rects &lt;- graph_scaled_nodes %&gt;% copy_node_attrs( node_attr_from = &quot;width&quot;, node_attr_to = &quot;height&quot;) # Display the graph and observe squares render_graph(graph_square_rects) Let’s move onto some modifications of the edges. We have already applied some color values manually when constructing the edge data frame before its incorporation into the graph. Let’s use the data values available in the internal edge data frame to create scaled colors. We’ll essentially replace the color attribute values already present and scale between the grey85 and grey25 colors with the rescale_edge_attrs() function. # Create the `color` edge attribute column # by scaling the values in the `data` column # to between the `grey85` to `grey25` colors graph_grey_edges &lt;- graph_square_rects %&gt;% rescale_edge_attrs( edge_attr_from = &quot;data&quot;, to_lower_bound = &quot;grey85&quot;, to_upper_bound = &quot;grey25&quot;, edge_attr_to = &quot;color&quot;) # Display the graph with newly grayed edges render_graph(graph = graph_grey_edges) 3.3 Setting Attributes Globally or Selectively We can set node or edge attribute values for all nodes or edges in a graph, or, for specific nodes or edges in a graph. These additions can be done with the set_node_attrs() and set_edge_attrs() functions. Let’s create a random graph with 10 nodes and 15 edges and color some nodes and edges. # Create a random graph and set the # `fillcolor` as `lightgreen` for all # nodes in the graph, and, set `color` # as `blue` for all graph edges graph_1 &lt;- create_random_graph( n = 10, m = 15, directed = TRUE, set_seed = 23) %&gt;% set_node_attrs( node_attr = &quot;fillcolor&quot;, values = &quot;lightgreen&quot;) %&gt;% set_edge_attrs( edge_attr = &quot;color&quot;, values = &quot;blue&quot;) # Display the blue and green graph render_graph(graph = graph_1) We can be more selective with the node and edge coloring (or with any other attributes or data we would like to apply). # Set attribute `fillcolor` as `orange` # for nodes `1` and `3` in the graph; # for edges, set `color` to `red` for # all those edges leading to nodes # `7` and `10` graph_2 &lt;- graph_1 %&gt;% set_node_attrs( node_attr = &quot;fillcolor&quot;, values = &quot;orange&quot;, nodes = c(1, 3)) %&gt;% set_edge_attrs( edge_attr = &quot;color&quot;, values = &quot;red&quot;, to = c(7, 10)) # Display that multicolored graph render_graph(graph = graph_2) Finally, individual edges can be targeted if supplying vectors for both the from and to arguments. # Set attribute `color = &quot;green&quot;` for edges # `1`-&gt;`4` and `3`-&gt;`1` using the edge # data frame graph_3 &lt;- graph_2 %&gt;% set_edge_attrs( edge_attr = &quot;color&quot;, values = &quot;black&quot;, from = c(7, 1), to = c(9, 6)) # Display the graph render_graph(graph = graph_3) 3.4 Adding Attributes to Selections of Nodes or Edges There is a large number of functions that store either a selection of nodes or edges within the graph object. Such functions begin with select_... and trav_.... Complementing this class of functions are functions that take a graph with an active selection and perform some transformation based on the selection of nodes or edges. These functions are identifiable by ending with ...ws (with selection). We’ll devote two entire chapters on the select...() and trav...() functions but, for now, we’ll provide simple use cases with select_nodes() and select_edges(). So, we can make a selection of nodes or edges (but not both at the same time), how do we style these groups? We can do it with the set_node_attrs_ws() and set_edge_attrs_ws() functions. In this example, let’s make a simple graph, select 2 of the 4 nodes using select_nodes() and specifying nodes = c(1, 2), add fillcolor attribute values of lightgreen for those nodes with set_node_attrs_ws(), and then clear the selection with clear_selection() (it clears any selection of nodes or edges). # Create a simple graph, select nodes # `1` and `2`, color them light green; # clear the selection graph_4 &lt;- create_graph() %&gt;% add_path(4) %&gt;% select_nodes( nodes = c(1, 2)) %&gt;% set_node_attrs_ws( node_attr = &quot;fillcolor&quot;, value = &quot;lightgreen&quot;) %&gt;% clear_selection() # As a further aside on functions, we # can equivalently use the function # `select_nodes_by_id()` in the place # of `select_nodes()` in this instance # and achieve the same result; let&#39;s # now render the graph render_graph(graph = graph_4) We can follow a similar sequence for modifying edge attributes for some edges with select_edges() and set_edge_attrs_ws(). Note that we also use clear_selection() as before to clear the active selection which is, in this case, a selection of edges. # Take `graph_4`, select edges # `1-&gt;2` and `2-&gt;3`, color those red # and then clear the selection graph_5 &lt;- graph_4 %&gt;% select_edges( from = c(1, 2), to = c(2, 3)) %&gt;% set_edge_attrs_ws( edge_attr = &quot;color&quot;, value = &quot;red&quot;) %&gt;% clear_selection() render_graph(graph = graph_5) There are a few more select_...() functions that are useful and they allow you to make selections based on properties of nodes or edges in a graph. For nodes, these include: select_nodes_by_degree(): supply some information on degree (number of connections to/from/total for a node) to an expressions argument and a selection of nodes satisfying the expressions will be made select_nodes_in_neighborhood(): create a selection of based on a walk distance from a specified node (supplying a single node ID for node) select_last_nodes_created(): if you just created a large amount of nodes, you can select them straight away with this function and this apply some transformation with a ..._ws() function like set_node_attrs_ws() The select_nodes() function also has some advanced functionality that can be accessed by supplying filtering statements to its conditions argument. Moreover, the select_edges() also has selective filtering capabilities. More details are available on this in a later chapter, but, it is good to know that this is possible now. In addition, edges can be selected with: select_edges_by_edge_id(): given some edge ID values, select those exact edges select_edges_by_node_id(): given some node ID values, select all edges associated (i.e., linked to or from) those nodes select_last_edges_created(): analogous to the select_last_nodes_created() function; useful for applying attribute values to just-created edges These functions are best illustrated with a few examples. First, let’s make a random graph (30 nodes and 50 edges) and select nodes with a total degree (number of edges inbound + number of edges outbound) greater than or equal to 6. The graph will be generated by the create_random_graph() function, the selection will be performed by the select_nodes_by_degree() function (using expressions = &quot;deg &gt;= 6&quot; to express our filtering of nodes by total degree), and the coloring of the selected nodes will be accomplished using the set_node_attrs_ws() function. We’ll also do another interesting thing: color all nodes not satisfying our stated condition. This last modification will be done by inverting the node selection with invert_selection() and then using set_node_attrs_ws() again, this time on the complementary node selection. # Create a random graph and label # nodes by letters of the alphabet graph_26n_52e &lt;- create_random_graph( n = 26, m = 52, directed = TRUE, set_seed = 23) %&gt;% set_node_attrs( node_attr = &quot;label&quot;, values = LETTERS) %&gt;% set_node_attrs( node_attr = &quot;type&quot;, values = &quot;letter&quot;) # Select nodes that have a (total) # degree &gt;= 6, color these nodes # `purple` and the rest `lightgreen` graph_26n_52e &lt;- graph_26n_52e %&gt;% select_nodes_by_degree( expressions = &quot;deg &gt;= 6&quot;) %&gt;% set_node_attrs_ws( node_attr = &quot;fillcolor&quot;, value = &quot;purple&quot;) %&gt;% invert_selection() %&gt;% set_node_attrs_ws( node_attr = &quot;fillcolor&quot;, value = &quot;lightgreen&quot;) %&gt;% clear_selection() # Render the graph render_graph(graph = graph_26n_52e) Interesting! And we’re starting to visualize something of a useful insight, nodes that have greater connectedness than other nodes (distinguished by level of total degree) stand out by a visual aesthetic. This methodology is not limited to the visual either. We could, for instance, provide information on the nodes that have fulfilled the node degree requirements for reporting purposes. One can always retrieve the selection of nodes with the get_selection() function: hi_deg_nodes &lt;- graph_26n_52e %&gt;% select_nodes_by_degree( expressions = &quot;deg &gt;= 6&quot;) %&gt;% get_selection() # Report the node IDs that have # exceptionally high degree values paste( &quot;Nodes&quot;, paste(hi_deg_nodes, collapse = &quot;, &quot;), &quot;all have high degree.&quot;) ## [1] &quot;Nodes 4, 5, 8, 14, 17, 20 all have high degree.&quot; Getting a targeted list of node IDs is a great start, however, node ID values aren’t usually very meaningful to the end user. Usually, we ascribe labels to nodes to represent entities we’d like to model in the graph. Examples include (unique) user names, gene identifers, project names, etc. So, let’s get the values associated with the label and values node attributes in the selection. One strategy for doing this is involves the following sequence of functions: select_nodes_by_degree() (as before), create_subgraph_ws() to makes a graph subset based on the selection of nodes, get_node_df() to return a data frame containing the graph’s nodes and all attributes (the internal node data frame), and, finally, dplyr’s select() function to select only those data frame columns we want to keep (label and value). # Load in the dplyr package library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union # Get a data frame of node `label` # and associated data values for # nodes with total degree &gt;= 6 hi_deg_node_data &lt;- graph_26n_52e %&gt;% select_nodes_by_degree( expressions = &quot;deg &gt;= 6&quot;) %&gt;% create_subgraph_ws() %&gt;% get_node_df() %&gt;% dplyr::select(label, value) # Display the final data frame hi_deg_node_data ## label value ## 1 D 7.5 ## 2 E 8.5 ## 3 H 10.0 ## 4 N 3.5 ## 5 Q 5.5 ## 6 T 6.5 This is more like it! But imagine that these label values could convey more meaning in a selected domain, like city names, species names, user names, or other names for things. "],
["selections.html", "Chapter 4 Selections 4.1 The Selection Functions 4.2 Creating a Node Selection 4.3 Consecutive Selections", " Chapter 4 Selections Occasionally, you’ll want to operate on a select group of nodes or edges. Some functions affect a single node or edge while others (or, sometimes, the same functions) operate on all nodes or edges in a graph. Selections allow you to target specified nodes or edges and then apply specialized functions to operate on just those selected entities. Most of the selection functions support rudimentary set operations across several calls of the selection functions (i.e., for the union, intersection, or difference between selection sets of nodes or edges). 4.1 The Selection Functions The following table provides a summary of all the available select_...() functions available in DiagrammeR. Function Description select_nodes() Select nodes graph using filtering conditions. select_nodes_by_id() Select nodes by their ID values. select_last_nodes_created() Select the last group of nodes created in the graph. select_nodes_by_degree() Select nodes on the basis of node degree. select_nodes_in_neighbourhood() Select nodes based on a walk distance from a specified node. select_edges() Select nodes graph using filtering conditions. select_edges_by_edge_id() Select edges by their ID values. select_edges_by_node_id() Select edges associated with specified node ID values. select_last_edges_created() Select the last group of edges created in the graph. select_rev_edges_ws() Select any reverse edges from a selection of edges. When any selection is performed using using a select_...() function, the selection is stored in the graph object. We can always use get_selection() to verify this: 4.2 Creating a Node Selection Let’s begin with an in-depth look on how to select graph nodes using the select_nodes() function. Selecting nodes in a graph with select_nodes() can be done in multiple ways: providing only a set of node ID values by providing one or more filtering statements to conditions doing both of the above, where each set of values/statements work toward filtering the nodes that will comprise the node selection Here is an example of the first case, where you know which node ID values should make up the node selection: # Create a 5-node graph and select # nodes `1` and `3`; show # the final node selection create_graph() %&gt;% add_n_nodes(5) %&gt;% select_nodes(nodes = c(1, 3)) %&gt;% get_selection() ## [1] 1 3 The select_nodes_by_id() function serves as a plug-in replacement for select_nodes() when used exactly in this way. Its nodes argument simply takes a vector of node ID values. # Create a 5-node graph and select # nodes `1` and `3` using the # `select_nodes_by_id()` function create_graph() %&gt;% add_n_nodes(5) %&gt;% select_nodes_by_id(nodes = c(1, 3)) %&gt;% get_selection() ## [1] 1 3 4.3 Consecutive Selections The situation may arise when a more specialized match needs to be made (i.e., matching this but not that, or, matching two different types of things). This is where the set_op argument (short for set operation) becomes useful. Multiple function calls with the select_nodes_by_id() function, for instance, can modify the set of selected nodes depending on the option provided in the set_op argument. These set operations are: union — creates a union of selected nodes in consecutive operations that create a selection of nodes (this is the default option) intersect — modifies the list of selected nodes such that only those nodes common to both consecutive node selection operations will retained difference — modifies the list of selected nodes such that the only nodes retained are those that are different in the second node selection operation compared to the first These set operations behave in exactly the same way as the base R functions union(), intersect(), and setdiff(). Furthermore, most of the select_...() functions contain the set_op argument, so, they behave the same way with regard to modifying the node or edge selection in a series of consecutive selection operations. For a graph with 5 nodes (with IDs 1 through 5), creating an initial selection of nodes with select_nodes() will result in the selection of all 10 nodes in the graph. A subsequent call of select_nodes_by_id() specifying nodes = c(1, 3, 5) and set_op = &quot;difference&quot; will result in a selection of nodes 2 and 4. We can verify the selection any time with the get_selection() function. Here is a the complete pipeline, starting with create_graph() and finishing with get_selection(): # Create a 5-node graph and use 2 # `select_...()` functions; show # the final node selection create_graph() %&gt;% add_n_nodes(5) %&gt;% select_nodes() %&gt;% select_nodes_by_id( nodes = c(1, 3, 5), set_op = &quot;difference&quot;) %&gt;% get_selection() ## [1] 2 4 "]
]
